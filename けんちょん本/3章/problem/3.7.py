S = input()
N = len(S)

ans = 0

for bit in range(2**(N-1)):
    tmp = 0 # 「+」と「+」の間の値を表す変数
    for i in range(N-1):
        tmp *= 10 # 桁をずらす
        tmp += int(S[i])

        if bit & (1<<i): # + が入る場合は ansにtmpを合計して tmpを0に初期化する
            ans += tmp
            tmp = 0
    
    # 最後の1文字の処理
    tmp *= 10 
    tmp += int(S[-1])
    ans += tmp        

print(ans)


# 解説
"""
長さNの文字列には文字と文字の間が N-1 個ある
各文字の間に + を入れる,入れないを考えるのでbit全探索を用いる
bit は0から2^(N-1)-1まで動く、そのbitとの論理積は i が0からN-2まで考えるので計算量はO((N-1)*2^(N-1))つまり、O(N2^(N-1))となる

bit全探索中の処理について
Sの先頭から1文字ずつ考えていく。つまりS=125であった場合、1,2,5と考える
bitについてはb01であった場合、1 + 2  5 となる。(先頭から何番目の間が+になるかを表す)

tmpについて
S=125でも良いが、処理の理解をしやすくするためにS=1234、bit=b001の場合について考える。つまり 1 + 234の場合を考える
ansに加える時点でのtmpの値はそれぞれ1,234となる
はじめにtmp=0で初期化する。
 i=0のとき、まず*10されるが tmp = 0 。次にS[0]=1であるからtmp = 1となる。
if文はTrueとなるので ansにtmpを加え、また0で初期化する。
 i=1のとき、まず*10されるが tmp = 0 。次にS[1]=2であるからtmp = 2となる。
if文はFalseとなるので ansには加えず、0で初期化もしない
 i=2のとき、*10して tmp = 20 。次にS[2]=3であるからtmp = 23となる。(このことから*10は桁をずらしている操作にあたることがわかる)
if文はFalseとなるので ansには加えず、0で初期化もしない
 最後1文字の処理を行う。*=10するのでtmp=230となり、S[-1]=4であるからtmp = 234となる。
これをansに足してこのbit=b001の場合のループは終了となる。


bit演算について
1 << i : 1をiビット左にシフトする
X & Y : XとYの論理積を10進数表記したもの
X & (1<<i) : Xを2進数表記した際にi桁目の数が1であるかどうかを表す(戻ってくる値は10進数変換されていることに注意)

(ex)
12 & (1 << 2)のとき、12 = b1100であり、1<<2 = b100であるから、12 & (1<<2) = b0100 = 8となる。つまりこの値をTrueとして扱う
12 & (1 << 1)のとき、12 = b1100であり、1<<1 = b10であるから、12 & (1<<1) = b0000 = 0となる。つまりこの値をFalseとして扱う
"""